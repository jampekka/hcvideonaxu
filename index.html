<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hypercatatoniavideonaxu</title>

<style>
    :root {
        --m: 10px;
    }

    html,
    body {
        height: 100%;
        margin: 0;
        color: white;
        background-color: black;
    }

    body {
        font-family: system-ui, sans-serif;
    }

    #introScreen,
    #loadingScreen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: black;
    }

    #loadingScreen {
        z-index: 90;
    }

    /* App layout: toolbar on top, stage fills the rest */
    #app {
        display: flex;
        flex-direction: column;
        height: 100vh;
    }

    #toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: var(--m);
        border-bottom: 1px solid #222;
    }

    #main {
        display: flex;
        flex-direction: row;
        height: 100%;
    }

    #markerTable {
        width: 200px;
        /*border-collapse: collapse;*/
        border: 1px solid #222;
        height: auto;
        align-self: flex-start;
    }

    #markerTable th,
    #markerTable td {
        border-top: 1px solid #222;
        padding: 2px 4px;
        min-width: 6ch;
    }

    #video {
        flex: 1 1 0;
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: #000;
        cursor: crosshair;
    }

    #frameContainer {
        /* The aspect ratio of this will be
           defined later using the video dimensions */
        aspect-ratio: 16 / 9;
        position: absolute;
        inset: 0;
        margin: auto;
        max-width: 100%;
        max-height: 100%;
    }

    #frame,
    #overlay {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    #frame {
        background: black;
        object-fit: contain;
    }

    #overlay {
        pointer-events: none;
        z-index: 1;
    }

    #seekingOverlay {
        position: absolute;
        inset: 0;
        opacity: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3em;
        color: white;
        pointer-events: none;
    }

    #seekingOverlay.visible {
        opacity: 1;
        transition: opacity 0.3s linear 0.3s;
    }

    .marker {
        position: absolute;
        opacity: 0.5;
        width: 8px;
        height: 8px;
        background: black;
        border: 3px solid white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }

    .marker-label {
        position: absolute;
        right: -16px;
        bottom: -12px;
        font-size: 14px;
        color: white;
        text-shadow: 2px 2px 0px black;
        border-radius: 3px;
        padding: 0 2px;
        pointer-events: none;
        user-select: none;
    }

    label,
    button {
        background: #eee;
        color: black;
        border-radius: 4px;
        cursor: pointer;
        padding: 8px 16px;
        font-size: 1em;
        border: 1px solid #bbb;
    }

    .posIndicators>div {
        min-width: 4em;
        text-align: right;
        font-family: monospace;
        font-size: 1.5em;
        white-space: nowrap;
    }

    input.rawnumber::-webkit-outer-spin-button,
    input.rawnumber::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    input.rawnumber[type=number] {
        -moz-appearance: textfield;
        text-align: right;
        width: 6em;
        min-width: 6em;
    }

    input.rawnumber[type=number] {
        appearance: textfield;
    }

    form {
        display: contents;
        margin: 0;
        padding: 0;
        border: none;
    }

    #frameSlider {
        cursor: text;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #frameSliderBar {
        position: relative;
        display: flex;
        align-items: center;
        border: 2px solid #ccc;
        height: 8px;
        width: 100%;
    }

    .frameSliderMarker {
        position: absolute;
        height: 100%;
        background-color: white;
        opacity: 0.5;
        pointer-events: none;
        min-width: 1px;
    }

    #frameCursor {
        position: absolute;
        height: 24px;
        width: 2px;
        background-color: #ccc;
        will-change: left;
    }

    #status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--m);
        border-top: 1px solid #222;
        font-size: 0.9em;
    }
</style>

<body>
    <div id="introScreen">
        <h1>Hypercatatoniavideonaxu!</h1>
        <input type="file" id="file" accept="video/*" style="display:none;">
        <label for="file" id="fileLabel">
            Select Video
        </label>
        <a id="downloadAllSessions" style="color: white; opacity: 0.7; margin: 3em;" href="#">Download all sessions</a>
    </div>
    <div id="loadingScreen">
        <h1>Loading...</h1>
    </div>
    <div id="app">
        <div id="toolbar">
            <div class="posIndicators">
                <div>
                    <form id="timeForm"><input class="rawnumber" type="number" id="currentTime" value="0.00"
                            step="0.01"></form>s
                </div>
                <div>
                    <form id="frameForm"><input class="rawnumber" type="number" id="currentFrame" value="0" step="1">
                    </form>&nbsp
                </div>
            </div>

            <!--<input type="range" id="frameSlider" min="0" max="0" value="0" style="flex:1;" disabled>-->
            <div id="frameSlider">
                <div id="frameSliderBar">
                    <div id="frameCursor"></div>
                </div>
            </div>
            <button id="prevMarkerFrame">Prev</button>
            <button id="nextMarkerFrame">Next</button>
            <div class=""></div>
        </div>

        <div id="main">
            <div id="video">
                <div id="frameContainer">
                    <canvas id="frame"></canvas>
                    <div id="overlay"></div>
                    <div id="seekingOverlay">Seeking</div>
                </div>
            </div>
            <table id="markerTable">
                <thead>
                    <tr>
                        <th>Marker</th>
                        <th>x</th>
                        <th>y</th>
                        <th>&nbsp;</th>
                    </tr>
                </thead>
                <tbody id="markerTableBody">
                    <!-- Markers will be populated here -->
                </tbody>
            </table>
        </div>
        <div id="status">
            <div style="white-space: nowrap;">
                <span id="fileName"></span> |
                Duration: <span id="totalTime">-</span>s |
                Total frames: <span id="totalFrames">-</span> |
                FPS: <span id="videoFpsMedian"></span>Â±<span id="videoFpsIqr"></span>
            </div>
            <div style="display: flex; flex-direction: row;">
                <div style="white-space: nowrap; display: flex; align-items: center;">Min seek dt &nbsp;<input
                        id="minSeekDt" style="width: 8ch" type="number" value="0" step="0.1" /></div>
                <button id="saveMarkers">Save markers</button>
                <input type="file" id="doLoadMarkers" accept="application/json" style="display:none" />
                <label for="doLoadMarkers" id="loadMarkers">Load markers</label>

                <button id="clearMarkers">Clear markers</button>
                <button id="newSession" onclick="location.reload()">New session</button>
            </div>
        </div>

        <script type="module">
            import { Input, ALL_FORMATS, BlobSource, EncodedPacketSink, CanvasSink } from "https://esm.sh/mediabunny@latest"
            import Dexie, { liveQuery } from "https://esm.sh/dexie@3"
            import JSZip from "https://esm.sh/jszip@3.10.1"

            // ------------------------------
            // minimal helpers
            // ------------------------------
            const $ = s => document.querySelector(s)
            const fileInput = $('#file')
            const labelInput = $('#label')
            const info = $('#info')
            const frameCanvas = $('#frame')
            const overlay = $('#overlay')
            const markerTableBody = $('#markerTableBody')
            const ctx = frameCanvas.getContext('2d')

            const dbNameFor = (file) => `hcvnaxu-${file.name}_${file.size}_${file.lastModified}`

            const dbSchema = {
                markers: "[time+x+y+marker+insertedAt], frame, time, x, y, marker, insertedAt",
                videoInfo: "id"
            }

            // runtime state (per loaded file)
            let db, sub, input, vtrack, cSink
            let width = 0, height = 0
            let currentFrame = 0
            let pendingFrame = 0
            let minSeekDt = 0
            let frameTimes = [] // list of timestamps (seconds) from EncodedPacketSink (metadataOnly)
            let ready = false


            let mouseX = 0;
            let mouseY = 0;

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            // ------------------------------
            // file load -> setup everything
            // ------------------------------
            fileInput.onchange = async (e) => {
                const file = e.target.files[0]
                $("#introScreen").style.display = "none"

                $('#fileName').textContent = file.name

                const name = dbNameFor(file)
                //await Dexie.delete(name)
                db = new Dexie(name)
                db.version(1).stores(dbSchema)

                // mediabunny: input + track
                input = new Input({ formats: ALL_FORMATS, source: new BlobSource(file) })
                vtrack = await input.getPrimaryVideoTrack()

                // CanvasSink handles frame lifetimes/rotation; we draw its canvases to ours
                cSink = new CanvasSink(vtrack, { poolSize: 1, fit: 'contain' })

                // dimensions
                width = vtrack.displayWidth
                height = vtrack.displayHeight
                frameCanvas.width = width
                frameCanvas.height = height

                // Build metadata-only frame timestamp list (fast, no decode)
                const pSink = new EncodedPacketSink(vtrack)
                frameTimes = []
                for await (const pkt of pSink.packets(undefined, undefined, { metadataOnly: true })) {
                    frameTimes.push(pkt.timestamp)
                }

                frameTimes.sort((a, b) => a - b)

                function quantile(sortedArr, q) {
                    const pos = (sortedArr.length - 1) * q;
                    const base = Math.floor(pos);
                    const rest = pos - base;
                    if (sortedArr[base + 1] !== undefined) {
                        return sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base]);
                    } else {
                        return sortedArr[base];
                    }
                }

                // FPS stats
                let frameFpss = frameTimes.slice(1).map((t, i) => 1 / (t - frameTimes[i]));
                frameFpss.sort((a, b) => a - b);
                const fpsMedian = quantile(frameFpss, 0.5);
                const fpsIqr = (quantile(frameFpss, 0.75) - quantile(frameFpss, 0.25));
                $('#videoFpsMedian').textContent = fpsMedian.toFixed(2)
                $('#videoFpsIqr').textContent = fpsIqr.toFixed(2)

                // Store metadata (timestamps included) as a single object
                await db.videoInfo.clear()
                await db.videoInfo.add({ id: "meta", width, height, duration: frameTimes.at(-1) ?? 0, nFrames: frameTimes.length })

                // reactive markers
                sub?.unsubscribe?.()
                sub = liveQuery(() => db.markers.toArray()).subscribe(renderMarkers)


                $('#totalFrames').textContent = frameTimes.length
                $('#totalTime').textContent = (frameTimes.at(-1)).toFixed(2)

                ready = true
                setFrame(0)

                // --- minimal sanity tests ---
                console.assert(frameTimes.length > 0, 'No frame timestamps collected')
                const iter = cSink.canvases(frameTimes[0] ?? 0)
                const first = (await iter.next()).value
                console.assert(first && first.canvas, 'CanvasSink did not yield first frame')

                $("#loadingScreen").style.display = "none";
            }

            // Render a frame using CanvasSink by starting an iterator at the target timestamp
            /*async function drawFrame() {
                const t = frameTimes[currentFrame] ?? 0
                const c = await cSink.getCanvas(t)
                ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height)
                ctx.drawImage(c.canvas, 0, 0)
            }*/

            // markers rendering (HTML/CSS)
            async function renderMarkers(anns) {
                renderMarkerBar(anns)
                overlay.innerHTML = ""
                markerTableBody.innerHTML = ""
                const rect = frameCanvas.getBoundingClientRect()
                const t = frameTimes[currentFrame] ?? 0
                for (const a of anns) {
                    if (Math.abs(a.time - t) > 1e-6) continue
                    const m = document.createElement('div')
                    m.className = 'marker'
                    // Convert from source pixels to displayed CSS pixels
                    m.style.left = (a.x * 100) + '%'
                    m.style.top = (a.y * 100) + '%'
                    //m.title = a.marker || '?'

                    const letter = document.createElement('span')
                    letter.className = 'marker-label'
                    letter.textContent = a.marker
                    m.appendChild(letter)
                    overlay.appendChild(m)

                    // Add to marker table
                    const row = document.createElement('tr')
                    const markerCell = document.createElement('td')
                    markerCell.textContent = a.marker
                    const xCell = document.createElement('td')
                    xCell.textContent = a.x.toFixed(2)
                    const yCell = document.createElement('td')
                    yCell.textContent = a.y.toFixed(2)
                    const actionCell = document.createElement('td')
                    const deleteButton = document.createElement('button')
                    deleteButton.textContent = 'ðŸ—‘'
                    deleteButton.onclick = async () => {
                        await db.markers.delete([a.time, a.x, a.y, a.marker, a.insertedAt])
                        await renderMarkers(await db.markers.toArray())
                    }
                    actionCell.appendChild(deleteButton)
                    row.appendChild(markerCell)
                    row.appendChild(xCell)
                    row.appendChild(yCell)
                    row.appendChild(actionCell)
                    markerTableBody.appendChild(row)
                }
            }

            function renderMarkerBar(anns) {
                const bar = $('#frameSliderBar')
                bar.querySelectorAll('.frameSliderMarker').forEach(el => el.remove());
                const frameWidth = (1 / frameTimes.length) * 100 + '%'
                const frames = new Set(anns.map(m => m.frame))
                for (const frame of frames) {
                    const markerDiv = document.createElement('div')
                    markerDiv.className = 'frameSliderMarker'
                    const relPos = (frame / frameTimes.length) * 100
                    markerDiv.style.left = `${relPos}%`
                    markerDiv.style.width = frameWidth
                    bar.appendChild(markerDiv)
                }
            }

            // click to add annotation
            const addAnnotation = async (marker) => {
                if (!ready) return
                const rect = frameCanvas.getBoundingClientRect()
                const x = (mouseX - rect.left) / rect.width
                const y = (mouseY - rect.top) / rect.height
                const time = frameTimes[currentFrame]
                await db.markers.put({
                    time,
                    x, y,
                    marker,
                    frame: currentFrame,
                    insertedAt: new Date().toISOString()
                })
                // re-render markers immediately for snappier UX
                //await renderMarkers(await db.markers.toArray())
            }

            let rendering = false
            let renderedFrame = -1
            async function renderOnce(target) {
                const t = frameTimes[target] ?? 0
                const c = await cSink.getCanvas(t)
                ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height)
                ctx.drawImage(c.canvas, 0, 0)
                renderedFrame = target
                //console.log("Rendered frame", { renderedFrame, t })
                await renderMarkers(await db.markers.toArray())
            }

            // TODO: Indicate rendered vs target frame in UI
            const seekingOverlay = $('#seekingOverlay')
            async function pumpRender() {
                if (!ready || rendering) return
                //console.log("Pumping render", { ready, rendering, currentFrame })
                seekingOverlay.classList.add("visible");

                rendering = true
                const target = currentFrame
                try {
                    await renderOnce(target)
                } finally {
                    rendering = false
                }


                // If the desired frame changed while we were rendering, render again.
                if (currentFrame !== target) {
                    //console.log("Repumping", { target, renderedFrame, currentFrame })
                    pumpRender()
                } else {
                    seekingOverlay.classList.remove("visible");
                }


            }


            const setFrame = (n) => {
                if (!ready) return
                currentFrame = Math.min(Math.max(0, n), frameTimes.length - 1)
                $('#currentFrame').value = currentFrame
                $('#currentTime').value = (frameTimes[currentFrame] ?? 0).toFixed(2)
                // TODO: Should do with time
                const relFrame = currentFrame / frameTimes.length
                const sliderWidth = $('#frameSliderBar').clientWidth
                // TODO: Aligns to right of the cursor
                $('#frameCursor').style.left = `${Math.floor(relFrame * sliderWidth)}px`
                pumpRender()
            }

            const frameAt = (t) => {
                if (t <= frameTimes[0]) return 0
                if (t >= frameTimes[frameTimes.length - 1]) return frameTimes.length - 1
                let lo = 0, hi = frameTimes.length - 1, result = -1
                while (lo <= hi) {
                    const mid = Math.floor((lo + hi) / 2)
                    if (frameTimes[mid] <= t) {
                        result = mid
                        lo = mid + 1
                    } else {
                        hi = mid - 1
                    }
                }
                return result
            }

            const stepFrames = (n) => setFrame(currentFrame + n)
            const stepDts = (n) => {
                if (!ready) return
                const currentTime = frameTimes[currentFrame] ?? 0
                const targetTime = currentTime + n * minSeekDt
                let targetFrame = frameAt(targetTime)

                if (targetFrame === currentFrame) {
                    // Need to step at least one frame in the desired direction
                    targetFrame = currentFrame + Math.sign(n)
                }

                setFrame(targetFrame)

            }

            const wheelSeek = (e => {
                if (!ready) return
                if (e.deltaY < 0) stepDts(1)
                if (e.deltaY > 0) stepDts(-1)
                e.preventDefault()
            })

            $('#video').addEventListener('wheel', wheelSeek)
            $('#frameSlider').addEventListener('wheel', wheelSeek)
            $('#frameSlider').addEventListener('click', (e) => {
                const rect = e.target.getBoundingClientRect()
                const x = e.clientX - rect.left
                const relX = x / rect.width
                const newFrame = Math.floor(relX * frameTimes.length)
                setFrame(newFrame)
            })
            // TODO: Tooltip on frameSlider hover

            document.addEventListener('keydown', (e) => {
                if (!ready) return
                if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return; // Skip if any modifier is pressed

                const active = document.activeElement;
                if (active && (active.isContentEditable || active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;

                if (e.key === 'ArrowLeft') stepDts(-1)
                if (e.key === 'ArrowRight') stepDts(1)
                if (e.key === ' ') {
                    e.preventDefault()
                    stepDts(1)
                }

                if (/^[a-z0-9]$/.test(e.key)) {
                    addAnnotation(e.key)
                }
            })

            const seekNextMarker = async () => {
                const nextMarker = await db.markers
                    .where('frame')
                    .above(currentFrame)
                    .first();

                if (nextMarker) {
                    setFrame(nextMarker.frame)
                }
            }
            $("#nextMarkerFrame").addEventListener("click", seekNextMarker)

            const seekPrevMarker = async () => {
                const prevMarker = await db.markers
                    .where('frame')
                    .below(currentFrame)
                    .last();

                if (prevMarker) {
                    setFrame(prevMarker.frame)
                }
            }
            $("#prevMarkerFrame").addEventListener("click", seekPrevMarker)

            $("#timeForm").addEventListener("submit", (e) => {
                e.preventDefault();
                const t = Number($("#currentTime").value);
                if (!isNaN(t) && frameTimes.length > 0) {
                    let closest = 0;
                    let minDiff = Math.abs(frameTimes[0] - t);
                    for (let i = 1; i < frameTimes.length; ++i) {
                        const diff = Math.abs(frameTimes[i] - t);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closest = i;
                        }
                    }
                    $("#currentTime").blur();
                    setFrame(closest);
                }
            });

            $("#frameForm").addEventListener("submit", (e) => {
                e.preventDefault()
                const frame = Number($("#currentFrame").value)
                if (!isNaN(frame)) {
                    $("#currentFrame").blur()
                    setFrame(frame)
                }
            });

            $("#minSeekDt").value = minSeekDt
            // TODO: Handle error conditions
            $("#minSeekDt").addEventListener("input", (e) => {
                const val = Number(e.target.value)
                if (!isNaN(val) && val >= 0) {
                    minSeekDt = val
                }
            })

            const dumpDb = async (db) => {
                const videoInfo = await db.videoInfo.toArray()
                const markers = await db.markers.orderBy('time').toArray()

                return { videoInfo, markers }
            }

            async function downloadAllSessions() {
                const dbs = await indexedDB.databases();
                const zip = new JSZip();

                for (const dbInfo of dbs) {
                    const dbName = dbInfo.name;
                    if (!dbName) continue;
                    if (!dbName.startsWith("hcvnaxu-")) continue;
                    try {
                        const db = new Dexie(dbName)
                        db.version(1).stores(dbSchema)
                        await db.open()
                        const dump = await dumpDb(db)
                        zip.file(`${dbName}.json`, JSON.stringify(dump, null, 2));
                        db.close();
                    } catch (e) {
                        console.warn("Failed to export", dbName, e);
                    }
                }

                const blob = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "hcvideonaxu-dump.zip";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            $("#downloadAllSessions").addEventListener('click', (e) => {
                e.preventDefault();
                downloadAllSessions();
            });


            const downloadMarkers = async () => {
                if (!db) return;

                const dump = await dumpDb(db)

                const blob = new Blob([JSON.stringify(dump, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = db.name + ".json"
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            $("#saveMarkers").addEventListener('click', downloadMarkers)

            $("#doLoadMarkers").addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const data = JSON.parse(e.target.result);
                        await db.markers.bulkPut(data.markers);
                    };
                    reader.readAsText(file);
                }

                event.target.value = ""
            })

            $("#clearMarkers").addEventListener('click', async () => {
                if (confirm("Clear all markers? This can't be undone.")) {
                    await db.markers.clear()
                }
            })
        </script>
</body>

</html>