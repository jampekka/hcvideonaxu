<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hypercatatoniavideonaxu</title>

<style>
    :root {
        --m: 10px;
    }

    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        font-family: system-ui, sans-serif;
    }

    /* App layout: toolbar on top, stage fills the rest */
    #app {
        display: flex;
        flex-direction: column;
        height: 100vh;
    }

    #toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: var(--m);
        border-bottom: 1px solid #e5e5e5;
    }

    #video {

        flex: 1 1 0;
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: #000;
    }

    #frameContainer {
        /* The aspect ratio of this will be
           defined later using the video dimensions */
        aspect-ratio: 16 / 9;
        position: absolute;
        inset: 0;
        margin: auto;
        max-width: 100%;
        max-height: 100%;
    }

    #frame,
    #overlay {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    #frame {
        background: black;
        object-fit: contain;
    }

    #overlay {
        pointer-events: none;
        z-index: 1;
    }

    .marker {
        position: absolute;
        width: 8px;
        height: 8px;
        background: red;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
</style>

<body>
    <div id="app">
        <div id="toolbar">
            <input type="range" id="frameSlider" min="0" max="0" value="0" style="flex:1;" disabled>
            <input type="file" id="file" accept="video/*" style="display:none;">
            <label for="file" id="fileLabel" style="padding:8px 16px; background:#eee; border-radius:4px; cursor:pointer;">
                Select Video
            </label>
        </div>

        <div id="video">
            <div id="frameContainer">
                <canvas id="frame"></canvas>
                <div id="overlay"></div>
            </div>
        </div>

        <div id="status">
            Time: <span id="currentTime">-</span>/<span id="totalTime">-</span>s
            &nbsp; | &nbsp
            Frame: <span id="currentFrame">-</span>/<span id="totalFrames">-</span>
        </div>
    </div>

    <script type="module">
        import { Input, ALL_FORMATS, BlobSource, EncodedPacketSink, CanvasSink } from "https://esm.sh/mediabunny@latest"
        import Dexie, { liveQuery } from "https://esm.sh/dexie@3"

        // ------------------------------
        // minimal helpers
        // ------------------------------
        const $ = s => document.querySelector(s)
        const fileInput = $('#file')
        const labelInput = $('#label')
        const info = $('#info')
        const frameCanvas = $('#frame')
        const overlay = $('#overlay')
        const ctx = frameCanvas.getContext('2d')

        const dbNameFor = (file) => `va-${file.name}:${file.size}:${file.lastModified}`

        // runtime state (per loaded file)
        let db, sub, input, vtrack, cSink
        let width = 0, height = 0
        let currentFrame = 0
        let pendingFrame = 0
        let frameTimes = [] // list of timestamps (seconds) from EncodedPacketSink (metadataOnly)
        let ready = false


        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // ------------------------------
        // file load -> setup everything
        // ------------------------------
        fileInput.onchange = async (e) => {
            const file = e.target.files[0]

            // fresh DB each run (dev). Remove Dexie.delete for persistence.
            const name = dbNameFor(file)
            await Dexie.delete(name)
            db = new Dexie(name)
            db.version(1).stores({
                annotations: "[time+x+y+marker+insertedAt], frame, time, x, y, marker, insertedAt",
                videoMetadata: "id"
            })

            // mediabunny: input + track
            input = new Input({ formats: ALL_FORMATS, source: new BlobSource(file) })
            vtrack = await input.getPrimaryVideoTrack()

            // CanvasSink handles frame lifetimes/rotation; we draw its canvases to ours
            cSink = new CanvasSink(vtrack, { poolSize: 1, fit: 'contain' })

            // dimensions
            width = vtrack.displayWidth
            height = vtrack.displayHeight
            frameCanvas.width = width
            frameCanvas.height = height

            // Build metadata-only frame timestamp list (fast, no decode)
            const pSink = new EncodedPacketSink(vtrack)
            frameTimes = []
            for await (const pkt of pSink.packets(undefined, undefined, { metadataOnly: true })) {
                frameTimes.push(pkt.timestamp)
            }

            frameTimes.sort((a, b) => a - b)

            const frameSlider = $('#frameSlider')
            frameSlider.max = frameTimes.length - 1
            frameSlider.disabled = false

            frameSlider.addEventListener('input', (e) => {
                setFrame(Number(e.target.value))
            })

            // Store metadata (timestamps included) as a single object
            await db.videoMetadata.clear()
            await db.videoMetadata.add({ id: "meta", width, height, duration: frameTimes.at(-1) ?? 0, frameTimes })

            // reactive markers
            sub?.unsubscribe?.()
            sub = liveQuery(() => db.annotations.toArray()).subscribe(renderMarkers)

            
            $('#totalFrames').textContent = frameTimes.length
            $('#totalTime').textContent = (frameTimes.at(-1)).toFixed(2)

            ready = true
            setFrame(0)

            // --- minimal sanity tests ---
            console.assert(frameTimes.length > 0, 'No frame timestamps collected')
            const iter = cSink.canvases(frameTimes[0] ?? 0)
            const first = (await iter.next()).value
            console.assert(first && first.canvas, 'CanvasSink did not yield first frame')
        }


        // Render a frame using CanvasSink by starting an iterator at the target timestamp
        /*async function drawFrame() {
            const t = frameTimes[currentFrame] ?? 0
            const c = await cSink.getCanvas(t)
            ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height)
            ctx.drawImage(c.canvas, 0, 0)
        }*/

        // markers rendering (HTML/CSS)
        async function renderMarkers(anns) {
            overlay.innerHTML = ""
            const rect = frameCanvas.getBoundingClientRect()
            const t = frameTimes[currentFrame] ?? 0
            for (const a of anns) {
                if (Math.abs(a.time - t) > 1e-6) continue
                const m = document.createElement('div')
                m.className = 'marker'
                // Convert from source pixels to displayed CSS pixels
                m.style.left = (a.x / width * rect.width) + 'px'
                m.style.top = (a.y / height * rect.height) + 'px'
                m.title = a.label || ''
                overlay.appendChild(m)
            }
        }

        // click to add annotation
        const addAnnotation = async (marker) => {
            if (!ready) return
            const rect = frameCanvas.getBoundingClientRect()
            const x = (mouseX - rect.left) * (width / rect.width)
            const y = (mouseY - rect.top) * (height / rect.height)
            const time = frameTimes[currentFrame]
            await db.annotations.put({
                time,
                x, y,
                marker,
                frame: currentFrame,
                insertedAt: new Date().toISOString() })
            // re-render markers immediately for snappier UX
            //await renderMarkers(await db.annotations.toArray())
        }

        let rendering = false
        let renderedFrame = -1
        async function renderOnce(target) {
            const t = frameTimes[target] ?? 0
            const c = await cSink.getCanvas(t)
            ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height)
            ctx.drawImage(c.canvas, 0, 0)
            renderedFrame = target
            //console.log("Rendered frame", { renderedFrame, t })
            await renderMarkers(await db.annotations.toArray())
        }

        async function pumpRender() {
            if (!ready || rendering) return
            //console.log("Pumping render", { ready, rendering, currentFrame })


            rendering = true
            const target = currentFrame
            try {
                await renderOnce(target)
            } finally {
                rendering = false
            }


            // If the desired frame changed while we were rendering, render again.
            if (currentFrame !== target) {
                //console.log("Repumping", { target, renderedFrame, currentFrame })
                pumpRender()
            }
        }


        const setFrame = (n) => {
            if (!ready) return
            currentFrame = Math.min(Math.max(0, n), frameTimes.length - 1)
            $('#currentFrame').textContent = currentFrame
            $('#currentTime').textContent = (frameTimes[currentFrame] ?? 0).toFixed(2)
            pumpRender()
        }


        const stepFrames = (n) => setFrame(currentFrame + n)

        document.addEventListener('keydown', (e) => {
            if (!ready) return
            if (e.key === 'ArrowLeft') stepFrames(-1)
            if (e.key === 'ArrowRight') stepFrames(1)

            if (/^[a-z0-9]$/.test(e.key)) {
                addAnnotation(e.key)
            }
        })
    </script>
</body>

</html>